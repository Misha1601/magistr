# import json
import sys
from scipy.optimize import minimize
from scipy.optimize import curve_fit
import pandas as pd
import numpy as np
from matplotlib import pyplot

# определяем DataFrame Мировой
data = pd.DataFrame({'year': [1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020],
                     'generate': [8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.420434564131, 38.3904519471421, 52.3307819867071, 62.9113953016839, 85.1161924282732, 104.083879757882, 132.859216030029, 170.682620580279, 220.600045153997, 276.020526299077, 346.465021938078, 440.385091980306, 530.55442135112, 635.49205101167, 705.805860788812, 831.42968828187, 962.227395409379, 1140.31094904253, 1269.52053571083, 1418.17004626655, 1591.2135122193]})

# data = pd.DataFrame({'year': [1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021],
#                      'generate': [0.003, 0.006, 0.0105, 0.0105, 0.0185, 0.327949494949495, 0.0447555555555555, 0.064220202020202, 0.138831313131313, 0.195376767676768, 0.331579797979798, 2.64977676767677, 3.63247051589899, 4.08670667470707, 4.73321201915152, 5.69756881939394, 7.12292984424242, 8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.4074350633309, 38.3814524463421, 52.3447824859071, 63.2853958008839, 85.6261929274732, 104.644334802537, 133.498282185794, 171.506693867357, 221.411045401997, 276.792526547077, 346.424604184064, 440.383768230808, 530.496436382213, 635.505147375046, 705.853688191986, 831.343777917725, 962.101686500868, 1140.39307285734, 1269.9792893104, 1420.54411006394, 1596.42821153965, 1861.93982399803]})

# data = pd.DataFrame({'year': [1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021],
#                      'generate': [8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.4074350633309, 38.3814524463421, 52.3447824859071, 63.2853958008839, 85.6261929274732, 104.644334802537, 133.498282185794, 171.506693867357, 221.411045401997, 276.792526547077, 346.424604184064, 440.383768230808, 530.496436382213, 635.505147375046, 705.853688191986, 831.343777917725, 962.101686500868, 1140.39307285734, 1269.9792893104, 1420.54411006394, 1596.42821153965, 1861.93982399803]})

# data = pd.DataFrame({'year': [1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020],
#                      'generate': [0.003, 0.006, 0.0105, 0.0105, 0.0185, 0.327949494949495, 0.0447555555555555, 0.064220202020202, 0.138831313131313, 0.195376767676768, 0.331579797979798, 2.64977676767677, 3.63247051589899, 4.08670667470707, 4.73321201915152, 5.69756881939394, 7.12292984424242, 8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.4074350633309, 38.3814524463421, 52.3447824859071, 63.2853958008839, 85.6261929274732, 104.644334802537, 133.498282185794, 171.506693867357, 221.411045401997, 276.792526547077, 346.424604184064, 440.383768230808, 530.496436382213, 635.505147375046, 705.853688191986, 831.343777917725, 962.101686500868, 1140.39307285734, 1269.9792893104, 1420.54411006394, 1596.42821153965]})


data['cum_sum'] = data['generate'].cumsum()
data['Sales'] = [0]+[data['generate'][i+1]-data['generate'][i] for i in range(data.shape[0]-1)]

finalYear = 2050  # Финальный год

def Bass(x, P, Q, M):
    """
    Функция расчета Prognose Sales
    x: величина Prognose Cumulative за прошлый год.
    """
    return (P*M+(Q-P)*(x))-(Q/M)*(x**2)

# Начальные значения параметров
# bounds = ([0, 0, 0], [np.inf, np.inf, np.inf])
popt, pcov = curve_fit(Bass, data.generate, data.Sales, bounds=(0, np.inf), method='trf', maxfev = 10000)
p0 = popt[0]
q0 = popt[1]
m0 = popt[2]
# p0 = 0.0000012
# q0 = 0.318
# m0 = 12

# Выводим стартовые коэффициенты
print('Стартовые коэффициенты:')
print('P0 =', p0)
print('Q0 =', q0)
print('M0 =', m0)

# print(data)

def squareMistake(k: tuple, *sales) -> float:
    """
    Функция для минимизации через scipy.
    Рассчитывает сумму квадратов разностей значений
    Prognose Cumulative и Prognose Sales.
    k: кортеж начальных параметров (P, Q, M);
    sales: кортеж Sales.
    """
    # Начальные значения для первого года
    p0 = 0  # Prognose Sales
    c0 = sales[0]  # Prognose Cumulative
    res = 0  # Значение функции
    # Набираем результат функции за годы
    for i in range(1, len(sales)):
        p = Bass(c0, P=k[0], Q=k[1], M=k[2])  # Новый Prognose Sales
        c = c0 + p  # Новый Prognose Cumulative
        res += (c - sales[i])**2  # Добавляем
        # Обновляем значения
        p0 = p
        c0 = c
    return res


# Формируем данные по годам
years1 = tuple(data.year)
gens = tuple(data.generate)

# Готовим данные для минимизации
k0 = [p0, q0, m0]  # Начальные значения параметров
kb = ((0, None), (0, None), (0, None))  # Все параметры неотрицательные

# Минимизируем сумму квадратов
res = minimize(squareMistake, k0, args=gens, method='Nelder-Mead', bounds=kb)

# При неудачной минимизации сообщаем и выходим
if not res.success:
    print('Не удалось минимизировать функцию.')
    sys.exit()

k = tuple(res.x)  # Получаем кортеж параметров (P, Q, M)

# Готовим данные для расчета прогнозов
years2 = [years1[0]]  # Задаем начальный год
prSales = [0]  # Задаем начальный Prognose Sales
prCumul = [gens[0]]  # Задаем начальный Prognose Cumulative

# Рассчитываем для всех лет
while years2[-1] < finalYear:
    years2.append(years2[-1]+1)  # Год
    prSales.append(Bass(prCumul[-1], P=k[0], Q=k[1], M=k[2]))  # Prognose Sales
    prCumul.append(prCumul[-1]+prSales[-1])  # Prognose Cumulative

# Формируем структуру выходных данных
dataOut = {}
dataOut['param'] = {'P': k[0], 'Q': k[1], 'M': k[2]}  # Параметры
dataOut['year'] = years2  # Года
dataOut['prSales'] = prSales  # Значения Prognose Sales
dataOut['prCumul'] = prCumul  # Значения Prognose Cumulative

# Выводим коэффициенты
print('Коэффициенты:')
print('P =', k[0])
print('Q =', k[1])
print('M =', k[2])

# Выводим графики для контроля
pyplot.plot(years1, gens, label='Sales fact')  # Исходный
pyplot.plot(years2, prCumul, label='Sales Bass')  # Расчитанный
pyplot.xlabel('year')  # Заголовок оси Х
pyplot.ylabel('generate')  # Заголовок оси Y
pyplot.legend()  # Отображаем имена данных
pyplot.show()  # Отображаем график

# метрика суммы квадратов остатков (Residual Sum of Squares, RSS). Чем меньше значение RSS, тем лучше кривая описывает данные
def rss(y_real, y_predicted):
    """Результат должен быть наименьшим, так как формула должна точно описывать логарифмическую кривую.
    Args:
        y_real (_type_): список или массив с реальными значениями, полученными из данных
        y_predicted (_type_): список или массив с предсказанными значениями на основе формулы.

    Returns:
        _type_: _description_
    """
    squared_residuals = np.square(np.subtract(y_real, y_predicted))
    return sum(squared_residuals)

# sales = np.array([data['Sales']])
# pr_Sales = np.array([i for i in prSales])
# print(len(gens))
# print(len(prCumul[:26]))
data['prCumul'] = prCumul[:len(gens)]
# y = Bass(gens, P, Q, M)
y_real = data['generate']
y_predicted = data['prCumul']
print(f"Сумма квадратов остатков - {rss(y_real, y_predicted)}")
# print(data)
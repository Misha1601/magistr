# import json
import sys
from scipy.optimize import minimize
from scipy.optimize import curve_fit
import pandas as pd
import numpy as np
from matplotlib import pyplot

# определяем DataFrame Мировой
data = pd.DataFrame({'year': [1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020],
                     'generate': [8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.420434564131, 38.3904519471421, 52.3307819867071, 62.9113953016839, 85.1161924282732, 104.083879757882, 132.859216030029, 170.682620580279, 220.600045153997, 276.020526299077, 346.465021938078, 440.385091980306, 530.55442135112, 635.49205101167, 705.805860788812, 831.42968828187, 962.227395409379, 1140.31094904253, 1269.52053571083, 1418.17004626655, 1591.2135122193],
                     'total':[13375.2439634053, 13789.2495277064, 14120.5171345097, 14502.9192434368, 14917.7637553936, 15555.5482906317, 15788.8606107222, 16345.4843195876, 16924.0184060025, 17726.7475122076, 18454.1188104507, 19155.2911176488, 20045.9829957051, 20421.6373537822, 20264.8910596484, 21570.6888619834, 22256.9952443638, 22806.2764799403, 23435.2382123808, 24031.7070496167, 24270.5009409496, 24915.1871081891, 25623.8922507836, 26659.1362380925, 27000.9508509267, 26823.2483500223]})

# data = pd.DataFrame({'year': [1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021],
#                      'generate': [0.003, 0.006, 0.0105, 0.0105, 0.0185, 0.327949494949495, 0.0447555555555555, 0.064220202020202, 0.138831313131313, 0.195376767676768, 0.331579797979798, 2.64977676767677, 3.63247051589899, 4.08670667470707, 4.73321201915152, 5.69756881939394, 7.12292984424242, 8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.4074350633309, 38.3814524463421, 52.3447824859071, 63.2853958008839, 85.6261929274732, 104.644334802537, 133.498282185794, 171.506693867357, 221.411045401997, 276.792526547077, 346.424604184064, 440.383768230808, 530.496436382213, 635.505147375046, 705.853688191986, 831.343777917725, 962.101686500868, 1140.39307285734, 1269.9792893104, 1420.54411006394, 1596.42821153965, 1861.93982399803]})

# data = pd.DataFrame({'year': [1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021],
#                      'generate': [8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.4074350633309, 38.3814524463421, 52.3447824859071, 63.2853958008839, 85.6261929274732, 104.644334802537, 133.498282185794, 171.506693867357, 221.411045401997, 276.792526547077, 346.424604184064, 440.383768230808, 530.496436382213, 635.505147375046, 705.853688191986, 831.343777917725, 962.101686500868, 1140.39307285734, 1269.9792893104, 1420.54411006394, 1596.42821153965, 1861.93982399803]})

# data = pd.DataFrame({'year': [1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020],
#                      'generate': [0.003, 0.006, 0.0105, 0.0105, 0.0185, 0.327949494949495, 0.0447555555555555, 0.064220202020202, 0.138831313131313, 0.195376767676768, 0.331579797979798, 2.64977676767677, 3.63247051589899, 4.08670667470707, 4.73321201915152, 5.69756881939394, 7.12292984424242, 8.26192344363636, 9.20460066059596, 12.0178164697778, 15.921260267805, 21.2161740066094, 31.4074350633309, 38.3814524463421, 52.3447824859071, 63.2853958008839, 85.6261929274732, 104.644334802537, 133.498282185794, 171.506693867357, 221.411045401997, 276.792526547077, 346.424604184064, 440.383768230808, 530.496436382213, 635.505147375046, 705.853688191986, 831.343777917725, 962.101686500868, 1140.39307285734, 1269.9792893104, 1420.54411006394, 1596.42821153965]})


data['cum_sum'] = data['generate'].cumsum()
data['Sales'] = [0]+[data['generate'][i+1]-data['generate'][i] for i in range(data.shape[0]-1)]

# print(data['cum_sum'])

finalYear = 2050  # Финальный год

p0 = 0.000824762472014628
q0 = 0.26375847458343
k0 = 0.0874734464635037
x = [13375.2439634053, 8.26192344363636]
m = 13375.2439634053
y = 8.26192344363636

def Bass(z, P, Q, K):
    """
    Функция расчета Prognose Sales
    m = М(t-1) общая генерация электроэнергии в предыдущий период за год
    y = Y(t-1) сумма предыдущих прогнозов, где y0 первое фактическое
        """
    m = z[0]
    y = z[1]
    return (P * m * K + (Q - P) * y - (Q / (m * K) * y ** 2))

# print(Bass(m, y, p0, q0, k0))
# Начальные значения параметров
total_values = np.array(data.total[0:-1])
generate_values = np.array(data.generate[1:])
z = np.array([total_values, generate_values])
Sales_values = np.array(data.Sales[1:])
popt, pcov = curve_fit(Bass, z, Sales_values, bounds=(0, np.inf), method='trf', maxfev = 10000)
p0 = popt[0]
q0 = popt[1]
k0 = popt[2]

# Выводим стартовые коэффициенты
# print('Стартовые коэффициенты:')
print('P0 =', p0)
print('Q0 =', q0)
print('K0 =', k0)

# print(data.total)

def squareMistake(k: tuple, sales) -> float:
    """
    Функция для минимизации через scipy.
    Рассчитывает сумму квадратов разностей значений
    Prognose Cumulative и Prognose Sales.
    k: кортеж начальных параметров (P, Q, M);
    sales: кортеж Sales.
    """
    # Начальные значения для первого года
    m = np.array(data.total)
    # print('начало функции')
    # print(m[0])
    y = data.generate[0]
    p0 = 0  # Prognose Sales
    c0 = sales[0]  # Prognose Cumulative
    # print(sales)
    # print(c0)
    res = 0  # Значение функции
    # Набираем результат функции за годы
    # print(sales[0])
    for i in range(1, len(sales)):
        # print(i)
        # p = Bass(m[i-1], y, P=k[0], Q=k[1], K=k[2])  # Новый Prognose Sales
        z = m[i-1], y
        p = Bass(z, P=k[0], Q=k[1], K=k[2])  # Новый Prognose Sales
        # print(f'Новый Prognose Sales = {p}')
        c = c0 + p  # Новый Prognose Cumulative
        # print(f'Новый Prognose Cumulative = {c}')
        # print(f'Generation = {sales[0][i]}')
        # print((c - sales[0][i])**2)
        res = res + (c - sales[i])**2  # Добавляем
        # print(f'Square Mistake = {res}')
        # Обновляем значения
        # p0 = p
        c0 = c
        y = y + p
    return res


# Формируем данные по годам
years1 = np.array(data.year)
gens = np.array(data.generate)
# print(gens[0])

# Готовим данные для минимизации
kp = [p0, q0, k0]  # Начальные значения параметров
kb = ((0, None), (0, None), (0, None))  # Все параметры неотрицательные

# print(gens[0:2])
# sm = squareMistake(kp, gens)
# print(sm)
# Минимизируем сумму квадратов
res = minimize(squareMistake, kp, args=gens, method='Nelder-Mead', bounds=kb)

# При неудачной минимизации сообщаем и выходим
if not res.success:
    print('Не удалось минимизировать функцию.')
    sys.exit()

k = tuple(res.x)  # Получаем кортеж параметров (P, Q, M)
print(k)
# Готовим данные для расчета прогнозов
ind_tgen = 1
years2 = [years1[0]]  # Задаем начальный год
prSales = [0]  # Задаем начальный Prognose Sales
sum_prSales = gens[0]
prCumul = [gens[0]]  # Задаем начальный Prognose Cumulative
m = np.array(data.total)

m = np.pad(m, (0, finalYear - years1[0]), 'edge')

# Рассчитываем для всех лет
while years2[-1] < finalYear:
# while years2[-1] < 2020:
    years2.append(years2[-1]+1)  # Год
    z = m[ind_tgen - 1], sum_prSales
    bs = Bass(z, P=k[0], Q=k[1], K=k[2])
    prSales.append(bs)  # Prognose Sales
    prCumul.append(prCumul[-1]+prSales[-1])  # Prognose Cumulative
    sum_prSales += bs
    ind_tgen += 1

# print(years1)
# print(years2)
# print(prSales)
# Формируем структуру выходных данных
# dataOut = {}
# dataOut['param'] = {'P': k[0], 'Q': k[1], 'M': k[2]}  # Параметры
# dataOut['year'] = years2  # Года
# dataOut['prSales'] = prSales  # Значения Prognose Sales
# dataOut['prCumul'] = prCumul  # Значения Prognose Cumulative

# Выводим коэффициенты
# print('Коэффициенты:')
# print('P =', k[0])
# print('Q =', k[1])
# print('K =', k[2])

# Выводим графики для контроля
pyplot.plot(years1, gens, label='Sales fact')  # Исходный
pyplot.plot(years2, prCumul, label='Sales Bass')  # Расчитанный
pyplot.xlabel('year')  # Заголовок оси Х
pyplot.ylabel('generate')  # Заголовок оси Y
pyplot.legend()  # Отображаем имена данных
pyplot.show()  # Отображаем график

# метрика суммы квадратов остатков (Residual Sum of Squares, RSS). Чем меньше значение RSS, тем лучше кривая описывает данные
# def rss(y_real, y_predicted):
#     """Результат должен быть наименьшим, так как формула должна точно описывать логарифмическую кривую.
#     Args:
#         y_real (_type_): список или массив с реальными значениями, полученными из данных
#         y_predicted (_type_): список или массив с предсказанными значениями на основе формулы.

#     Returns:
#         _type_: _description_
#     """
#     squared_residuals = np.square(np.subtract(y_real, y_predicted))
#     return sum(squared_residuals)

# data['prCumul'] = prCumul[:len(gens)]
# y_real = data['generate']
# y_predicted = data['prCumul']
# print(f"Сумма квадратов остатков - {rss(y_real, y_predicted)}")
